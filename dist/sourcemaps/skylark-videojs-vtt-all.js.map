{"version":3,"sources":["skylark-videojs-vtt-all.js"],"names":["define","obj1","path","obj2","split","length","ns","i","name","_attach","skylark","attach","obj","main","globals","global","window","self","this","doccy","document","require","_objCreate","Object","create","F","o","arguments","Error","prototype","ParsingError","errorData","message","code","parseTimeStamp","input","computeSeconds","h","m","s","f","match","replace","Settings","values","parseOptions","callback","keyValueDelim","groupDelim","groups","kv","k","v","parseCue","cue","regionList","oInput","consumeTimeStamp","ts","Errors","BadTimeStamp","skipWhitespace","startTime","substr","endTime","settings","id","set","region","alt","vals","vals0","integer","percent","get","vertical","line","e","lineAlign","snapToLines","size","align","position","start","left","center","middle","end","right","positionAlign","consumeCueSettings","constructor","BadSignature","dflt","defaultKey","has","a","n","test","parseInt","parseFloat","TEXTAREA_ELEMENT","createElement","TAG_NAME","c","b","u","ruby","rt","lang","DEFAULT_COLOR_CLASS","white","lime","cyan","red","yellow","magenta","blue","black","TAG_ANNOTATION","NEEDS_PARENT","parseContent","nextToken","result","unescape","innerHTML","textContent","shouldAdd","current","element","localName","type","annotation","tagName","trim","t","rootDiv","tagStack","appendChild","createTextNode","pop","parentNode","node","createProcessingInstruction","classes","forEach","cl","bgColor","colorName","slice","hasOwnProperty","propName","propValue","style","className","join","push","strongRTLRanges","isStrongRTLChar","charCode","currentRange","StyleBox","CueStyleBox","styleOptions","call","cueDiv","text","styles","color","backgroundColor","top","bottom","display","writingMode","unicodeBidi","applyStyles","div","direction","nodeStack","childNodes","pushNodes","nextTextNode","innerText","charCodeAt","determineBidi","textAlign","font","whiteSpace","textPos","formatStyle","width","height","move","box","BoxPosition","lh","offsetHeight","offsetWidth","offsetTop","rects","getClientRects","getBoundingClientRect","Math","max","lineHeight","undefined","moveBoxToLinePosition","styleBox","containerBox","boxPositions","boxPosition","linePos","track","textTrackList","mediaElement","trackList","count","mode","computeLinePos","axis","step","round","maxPosition","initialAxis","abs","ceil","reverse","calculatedPercentage","bestPosition","specifiedPosition","percentage","overlapsOppositeAxis","within","overlapsAny","p","intersectPercentage","findBestPosition","toCSSCompatValues","WebVTT","prop","val","unit","toMove","overlaps","b2","boxes","container","x","min","y","intersectArea","reference","getSimpleBoxPosition","ret","StringDecoder","decode","data","decodeURIComponent","encodeURIComponent","convertCueToDOMTree","cuetext","processCues","cues","overlay","firstChild","removeChild","paddedOverlay","margin","hasBeenReset","displayState","shouldCompute","fontSize","Parser","vttjs","decoder","state","buffer","TextDecoder","reportOrThrowError","onparsingerror","parse","collectNextLine","pos","parseHeader","ontimestampmap","MPEGTS","LOCAL","xy","anchor","VTTRegion","lines","regionAnchorX","regionAnchorY","viewportAnchorX","viewportAnchorY","scroll","onregion","parseRegion","stream","alreadyCollectedLine","VTTCue","indexOf","hasSubstring","oncue","flush","onflush","autoKeyword","directionSetting","","lr","rl","alignSetting","auto","line-left","line-right","findAlignSetting","value","toLowerCase","_id","_pauseOnExit","_startTime","_endTime","_text","_region","_vertical","_snapToLines","_line","_lineAlign","_position","_positionAlign","_size","_align","defineProperties","enumerable","pauseOnExit","TypeError","setting","findDirectionSetting","SyntaxError","console","warn","getCueAsHTML","scrollSetting","up","isValidPercentValue","_width","_lines","_regionAnchorX","_regionAnchorY","_viewportAnchorX","_viewportAnchorY","_scroll","findScrollSetting"],"mappings":"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","file":"../skylark-videojs-vtt-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        return ns[name] = obj2;\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-langx-globals/globals',[\r\n\t\"skylark-langx-ns\"\r\n],function(ns) {\r\n\tvar globals = (function(){\r\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\r\n\t\t\t// global spec defines a reference to the global object called 'global'\r\n\t\t\t// https://github.com/tc39/proposal-global\r\n\t\t\t// `global` is also defined in NodeJS\r\n\t\t\treturn global;\r\n\t\t} else if (typeof window !== 'undefined') {\r\n\t\t\t// window is defined in browsers\r\n\t\t\treturn window;\r\n\t\t}\r\n\t\telse if (typeof self !== 'undefined') {\r\n\t\t\t// self is defined in WebWorkers\r\n\t\t\treturn self;\r\n\t\t}\r\n\t\treturn this;\r\n\t})();\r\n\r\n\treturn ns.attach(\"langx.globals\",globals);\r\n\r\n});\ndefine('skylark-langx-globals/document',[\n\t\"./globals\"\n], function(globals) {\n\tvar topLevel = typeof global !== 'undefined' ? global :\n\t    typeof window !== 'undefined' ? window : {};\n\n\tvar doccy;\n\n\tif (typeof document !== 'undefined') {\n\t    doccy = document;\n\t} else {\n        doccy  = require('min-document');\n\t}\n\n\n\treturn globals.document = doccy;\n});\n\n\n\n\ndefine('skylark-videojs-vtt/vtt',[\"skylark-langx-globals/document\"],function(document){\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n  /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n  var _objCreate = Object.create || (function() {\n    function F() {}\n    return function(o) {\n      if (arguments.length !== 1) {\n        throw new Error('Object.create shim only accepts one parameter.');\n      }\n      F.prototype = o;\n      return new F();\n    };\n  })();\n\n  // Creates a new ParserError object from an errorData object. The errorData\n  // object should have default code and message properties. The default message\n  // property can be overriden by passing in a message parameter.\n  // See ParsingError.Errors below for acceptable errors.\n  function ParsingError(errorData, message) {\n    this.name = \"ParsingError\";\n    this.code = errorData.code;\n    this.message = message || errorData.message;\n  }\n  ParsingError.prototype = _objCreate(Error.prototype);\n  ParsingError.prototype.constructor = ParsingError;\n\n  // ParsingError metadata for acceptable ParsingErrors.\n  ParsingError.Errors = {\n    BadSignature: {\n      code: 0,\n      message: \"Malformed WebVTT signature.\"\n    },\n    BadTimeStamp: {\n      code: 1,\n      message: \"Malformed time stamp.\"\n    }\n  };\n\n  // Try to parse input as a time stamp.\n  function parseTimeStamp(input) {\n\n    function computeSeconds(h, m, s, f) {\n      return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n    }\n\n    var m = input.match(/^(\\d+):(\\d{1,2})(:\\d{1,2})?\\.(\\d{3})/);\n    if (!m) {\n      return null;\n    }\n\n    if (m[3]) {\n      // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n      return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n    } else if (m[1] > 59) {\n      // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n      // First position is hours as it's over 59.\n      return computeSeconds(m[1], m[2], 0,  m[4]);\n    } else {\n      // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n      return computeSeconds(0, m[1], m[2], m[4]);\n    }\n  }\n\n  // A settings object holds key/value pairs and will ignore anything but the first\n  // assignment to a specific key.\n  function Settings() {\n    this.values = _objCreate(null);\n  }\n\n  Settings.prototype = {\n    // Only accept the first assignment to any key.\n    set: function(k, v) {\n      if (!this.get(k) && v !== \"\") {\n        this.values[k] = v;\n      }\n    },\n    // Return the value for a key, or a default value.\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n    // a number of possible default values as properties where 'defaultKey' is\n    // the key of the property that will be chosen; otherwise it's assumed to be\n    // a single value.\n    get: function(k, dflt, defaultKey) {\n      if (defaultKey) {\n        return this.has(k) ? this.values[k] : dflt[defaultKey];\n      }\n      return this.has(k) ? this.values[k] : dflt;\n    },\n    // Check whether we have a value for a key.\n    has: function(k) {\n      return k in this.values;\n    },\n    // Accept a setting if its one of the given alternatives.\n    alt: function(k, v, a) {\n      for (var n = 0; n < a.length; ++n) {\n        if (v === a[n]) {\n          this.set(k, v);\n          break;\n        }\n      }\n    },\n    // Accept a setting if its a valid (signed) integer.\n    integer: function(k, v) {\n      if (/^-?\\d+$/.test(v)) { // integer\n        this.set(k, parseInt(v, 10));\n      }\n    },\n    // Accept a setting if its a valid percentage.\n    percent: function(k, v) {\n      var m;\n      if ((m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/))) {\n        v = parseFloat(v);\n        if (v >= 0 && v <= 100) {\n          this.set(k, v);\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n\n  // Helper function to parse input into groups separated by 'groupDelim', and\n  // interprete each group as a key/value pair separated by 'keyValueDelim'.\n  function parseOptions(input, callback, keyValueDelim, groupDelim) {\n    var groups = groupDelim ? input.split(groupDelim) : [input];\n    for (var i in groups) {\n      if (typeof groups[i] !== \"string\") {\n        continue;\n      }\n      var kv = groups[i].split(keyValueDelim);\n      if (kv.length !== 2) {\n        continue;\n      }\n      var k = kv[0];\n      var v = kv[1];\n      callback(k, v);\n    }\n  }\n\n  function parseCue(input, cue, regionList) {\n    // Remember the original input if we need to throw an error.\n    var oInput = input;\n    // 4.1 WebVTT timestamp\n    function consumeTimeStamp() {\n      var ts = parseTimeStamp(input);\n      if (ts === null) {\n        throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                              \"Malformed timestamp: \" + oInput);\n      }\n      // Remove time stamp from input.\n      input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n      return ts;\n    }\n\n    // 4.4.2 WebVTT cue settings\n    function consumeCueSettings(input, cue) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n        case \"region\":\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case \"vertical\":\n          settings.alt(k, v, [\"rl\", \"lr\"]);\n          break;\n        case \"line\":\n          var vals = v.split(\",\"),\n              vals0 = vals[0];\n          settings.integer(k, vals0);\n          settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n          settings.alt(k, vals0, [\"auto\"]);\n          if (vals.length === 2) {\n            settings.alt(\"lineAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n          }\n          break;\n        case \"position\":\n          vals = v.split(\",\");\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt(\"positionAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n          }\n          break;\n        case \"size\":\n          settings.percent(k, v);\n          break;\n        case \"align\":\n          settings.alt(k, v, [\"start\", \"center\", \"end\", \"left\", \"right\"]);\n          break;\n        }\n      }, /:/, /\\s/);\n\n      // Apply default values for any missing fields.\n      cue.region = settings.get(\"region\", null);\n      cue.vertical = settings.get(\"vertical\", \"\");\n      try {\n        cue.line = settings.get(\"line\", \"auto\");\n      } catch (e) {}\n      cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n      cue.snapToLines = settings.get(\"snapToLines\", true);\n      cue.size = settings.get(\"size\", 100);\n      // Safari still uses the old middle value and won't accept center\n      try {\n        cue.align = settings.get(\"align\", \"center\");\n      } catch (e) {\n        cue.align = settings.get(\"align\", \"middle\");\n      }\n      try {\n        cue.position = settings.get(\"position\", \"auto\");\n      } catch (e) {\n        cue.position = settings.get(\"position\", {\n          start: 0,\n          left: 0,\n          center: 50,\n          middle: 50,\n          end: 100,\n          right: 100\n        }, cue.align);\n      }\n\n\n      cue.positionAlign = settings.get(\"positionAlign\", {\n        start: \"start\",\n        left: \"start\",\n        center: \"center\",\n        middle: \"center\",\n        end: \"end\",\n        right: \"end\"\n      }, cue.align);\n    }\n\n    function skipWhitespace() {\n      input = input.replace(/^\\s+/, \"\");\n    }\n\n    // 4.1 WebVTT cue timings.\n    skipWhitespace();\n    cue.startTime = consumeTimeStamp();   // (1) collect cue start time\n    skipWhitespace();\n    if (input.substr(0, 3) !== \"-->\") {     // (3) next characters must match \"-->\"\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp,\n                             \"Malformed time stamp (time stamps must be separated by '-->'): \" +\n                             oInput);\n    }\n    input = input.substr(3);\n    skipWhitespace();\n    cue.endTime = consumeTimeStamp();     // (5) collect cue end time\n\n    // 4.1 WebVTT cue settings list.\n    skipWhitespace();\n    consumeCueSettings(input, cue);\n  }\n\n  var TEXTAREA_ELEMENT = document.createElement(\"textarea\");\n\n  var TAG_NAME = {\n    c: \"span\",\n    i: \"i\",\n    b: \"b\",\n    u: \"u\",\n    ruby: \"ruby\",\n    rt: \"rt\",\n    v: \"span\",\n    lang: \"span\"\n  };\n\n  // 5.1 default text color\n  // 5.2 default text background color is equivalent to text color with bg_ prefix\n  var DEFAULT_COLOR_CLASS = {\n    white: 'rgba(255,255,255,1)',\n    lime: 'rgba(0,255,0,1)',\n    cyan: 'rgba(0,255,255,1)',\n    red: 'rgba(255,0,0,1)',\n    yellow: 'rgba(255,255,0,1)',\n    magenta: 'rgba(255,0,255,1)',\n    blue: 'rgba(0,0,255,1)',\n    black: 'rgba(0,0,0,1)'\n  };\n\n  var TAG_ANNOTATION = {\n    v: \"title\",\n    lang: \"lang\"\n  };\n\n  var NEEDS_PARENT = {\n    rt: \"ruby\"\n  };\n\n  // Parse content into a document fragment.\n  function parseContent(window, input) {\n    function nextToken() {\n      // Check for end-of-string.\n      if (!input) {\n        return null;\n      }\n\n      // Consume 'n' characters from the input.\n      function consume(result) {\n        input = input.substr(result.length);\n        return result;\n      }\n\n      var m = input.match(/^([^<]*)(<[^>]*>?)?/);\n      // If there is some text before the next tag, return it, otherwise return\n      // the tag.\n      return consume(m[1] ? m[1] : m[2]);\n    }\n\n    function unescape(s) {\n      TEXTAREA_ELEMENT.innerHTML = s;\n      s = TEXTAREA_ELEMENT.textContent;\n      TEXTAREA_ELEMENT.textContent = \"\";\n      return s;\n    }\n\n    function shouldAdd(current, element) {\n      return !NEEDS_PARENT[element.localName] ||\n             NEEDS_PARENT[element.localName] === current.localName;\n    }\n\n    // Create an element for this tag.\n    function createElement(type, annotation) {\n      var tagName = TAG_NAME[type];\n      if (!tagName) {\n        return null;\n      }\n      var element = window.document.createElement(tagName);\n      var name = TAG_ANNOTATION[type];\n      if (name && annotation) {\n        element[name] = annotation.trim();\n      }\n      return element;\n    }\n\n    var rootDiv = window.document.createElement(\"div\"),\n        current = rootDiv,\n        t,\n        tagStack = [];\n\n    while ((t = nextToken()) !== null) {\n      if (t[0] === '<') {\n        if (t[1] === \"/\") {\n          // If the closing tag matches, move back up to the parent node.\n          if (tagStack.length &&\n              tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n            tagStack.pop();\n            current = current.parentNode;\n          }\n          // Otherwise just ignore the end tag.\n          continue;\n        }\n        var ts = parseTimeStamp(t.substr(1, t.length - 2));\n        var node;\n        if (ts) {\n          // Timestamps are lead nodes as well.\n          node = window.document.createProcessingInstruction(\"timestamp\", ts);\n          current.appendChild(node);\n          continue;\n        }\n        var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n        // If we can't parse the tag, skip to the next tag.\n        if (!m) {\n          continue;\n        }\n        // Try to construct an element, and ignore the tag if we couldn't.\n        node = createElement(m[1], m[3]);\n        if (!node) {\n          continue;\n        }\n        // Determine if the tag should be added based on the context of where it\n        // is placed in the cuetext.\n        if (!shouldAdd(current, node)) {\n          continue;\n        }\n        // Set the class list (as a list of classes, separated by space).\n        if (m[2]) {\n          var classes = m[2].split('.');\n\n          classes.forEach(function(cl) {\n            var bgColor = /^bg_/.test(cl);\n            // slice out `bg_` if it's a background color\n            var colorName = bgColor ? cl.slice(3) : cl;\n\n            if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {\n              var propName = bgColor ? 'background-color' : 'color';\n              var propValue = DEFAULT_COLOR_CLASS[colorName];\n\n              node.style[propName] = propValue;\n            }\n          });\n\n          node.className = classes.join(' ');\n        }\n        // Append the node to the current node, and enter the scope of the new\n        // node.\n        tagStack.push(m[1]);\n        current.appendChild(node);\n        current = node;\n        continue;\n      }\n\n      // Text nodes are leaf nodes.\n      current.appendChild(window.document.createTextNode(unescape(t)));\n    }\n\n    return rootDiv;\n  }\n\n  // This is a list of all the Unicode characters that have a strong\n  // right-to-left category. What this means is that these characters are\n  // written right-to-left for sure. It was generated by pulling all the strong\n  // right-to-left characters out of the Unicode data table. That table can\n  // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\n  var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],\n   [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],\n   [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],\n   [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],\n   [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],\n   [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],\n   [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],\n   [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],\n   [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],\n   [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],\n   [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],\n   [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],\n   [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],\n   [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],\n   [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],\n   [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],\n   [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],\n   [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],\n   [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],\n   [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],\n   [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],\n   [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],\n   [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],\n   [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],\n   [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n\n  function isStrongRTLChar(charCode) {\n    for (var i = 0; i < strongRTLRanges.length; i++) {\n      var currentRange = strongRTLRanges[i];\n      if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function determineBidi(cueDiv) {\n    var nodeStack = [],\n        text = \"\",\n        charCode;\n\n    if (!cueDiv || !cueDiv.childNodes) {\n      return \"ltr\";\n    }\n\n    function pushNodes(nodeStack, node) {\n      for (var i = node.childNodes.length - 1; i >= 0; i--) {\n        nodeStack.push(node.childNodes[i]);\n      }\n    }\n\n    function nextTextNode(nodeStack) {\n      if (!nodeStack || !nodeStack.length) {\n        return null;\n      }\n\n      var node = nodeStack.pop(),\n          text = node.textContent || node.innerText;\n      if (text) {\n        // TODO: This should match all unicode type B characters (paragraph\n        // separator characters). See issue #115.\n        var m = text.match(/^.*(\\n|\\r)/);\n        if (m) {\n          nodeStack.length = 0;\n          return m[0];\n        }\n        return text;\n      }\n      if (node.tagName === \"ruby\") {\n        return nextTextNode(nodeStack);\n      }\n      if (node.childNodes) {\n        pushNodes(nodeStack, node);\n        return nextTextNode(nodeStack);\n      }\n    }\n\n    pushNodes(nodeStack, cueDiv);\n    while ((text = nextTextNode(nodeStack))) {\n      for (var i = 0; i < text.length; i++) {\n        charCode = text.charCodeAt(i);\n        if (isStrongRTLChar(charCode)) {\n          return \"rtl\";\n        }\n      }\n    }\n    return \"ltr\";\n  }\n\n  function computeLinePos(cue) {\n    if (typeof cue.line === \"number\" &&\n        (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {\n      return cue.line;\n    }\n    if (!cue.track || !cue.track.textTrackList ||\n        !cue.track.textTrackList.mediaElement) {\n      return -1;\n    }\n    var track = cue.track,\n        trackList = track.textTrackList,\n        count = 0;\n    for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n      if (trackList[i].mode === \"showing\") {\n        count++;\n      }\n    }\n    return ++count * -1;\n  }\n\n  function StyleBox() {\n  }\n\n  // Apply styles to a div. If there is no div passed then it defaults to the\n  // div on 'this'.\n  StyleBox.prototype.applyStyles = function(styles, div) {\n    div = div || this.div;\n    for (var prop in styles) {\n      if (styles.hasOwnProperty(prop)) {\n        div.style[prop] = styles[prop];\n      }\n    }\n  };\n\n  StyleBox.prototype.formatStyle = function(val, unit) {\n    return val === 0 ? 0 : val + unit;\n  };\n\n  // Constructs the computed display state of the cue (a div). Places the div\n  // into the overlay which should be a block level element (usually a div).\n  function CueStyleBox(window, cue, styleOptions) {\n    StyleBox.call(this);\n    this.cue = cue;\n\n    // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n    // have inline positioning and will function as the cue background box.\n    this.cueDiv = parseContent(window, cue.text);\n    var styles = {\n      color: \"rgba(255, 255, 255, 1)\",\n      backgroundColor:  \"rgba(0, 0, 0, 0.8)\",\n      position: \"relative\",\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n      display: \"inline\",\n      writingMode: cue.vertical === \"\" ? \"horizontal-tb\"\n                                       : cue.vertical === \"lr\" ? \"vertical-lr\"\n                                                               : \"vertical-rl\",\n      unicodeBidi: \"plaintext\"\n    };\n\n    this.applyStyles(styles, this.cueDiv);\n\n    // Create an absolutely positioned div that will be used to position the cue\n    // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n    // mirrors of them except middle instead of center on Safari.\n    this.div = window.document.createElement(\"div\");\n    styles = {\n      direction: determineBidi(this.cueDiv),\n      writingMode: cue.vertical === \"\" ? \"horizontal-tb\"\n                                       : cue.vertical === \"lr\" ? \"vertical-lr\"\n                                                               : \"vertical-rl\",\n      unicodeBidi: \"plaintext\",\n      textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n      font: styleOptions.font,\n      whiteSpace: \"pre-line\",\n      position: \"absolute\"\n    };\n\n    this.applyStyles(styles);\n    this.div.appendChild(this.cueDiv);\n\n    // Calculate the distance from the reference edge of the viewport to the text\n    // position of the cue box. The reference edge will be resolved later when\n    // the box orientation styles are applied.\n    var textPos = 0;\n    switch (cue.positionAlign) {\n    case \"start\":\n      textPos = cue.position;\n      break;\n    case \"center\":\n      textPos = cue.position - (cue.size / 2);\n      break;\n    case \"end\":\n      textPos = cue.position - cue.size;\n      break;\n    }\n\n    // Horizontal box orientation; textPos is the distance from the left edge of the\n    // area to the left edge of the box and cue.size is the distance extending to\n    // the right from there.\n    if (cue.vertical === \"\") {\n      this.applyStyles({\n        left:  this.formatStyle(textPos, \"%\"),\n        width: this.formatStyle(cue.size, \"%\")\n      });\n    // Vertical box orientation; textPos is the distance from the top edge of the\n    // area to the top edge of the box and cue.size is the height extending\n    // downwards from there.\n    } else {\n      this.applyStyles({\n        top: this.formatStyle(textPos, \"%\"),\n        height: this.formatStyle(cue.size, \"%\")\n      });\n    }\n\n    this.move = function(box) {\n      this.applyStyles({\n        top: this.formatStyle(box.top, \"px\"),\n        bottom: this.formatStyle(box.bottom, \"px\"),\n        left: this.formatStyle(box.left, \"px\"),\n        right: this.formatStyle(box.right, \"px\"),\n        height: this.formatStyle(box.height, \"px\"),\n        width: this.formatStyle(box.width, \"px\")\n      });\n    };\n  }\n  CueStyleBox.prototype = _objCreate(StyleBox.prototype);\n  CueStyleBox.prototype.constructor = CueStyleBox;\n\n  // Represents the co-ordinates of an Element in a way that we can easily\n  // compute things with such as if it overlaps or intersects with another Element.\n  // Can initialize it with either a StyleBox or another BoxPosition.\n  function BoxPosition(obj) {\n    // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n    // was passed in and we need to copy the results of 'getBoundingClientRect'\n    // as the object returned is readonly. All co-ordinate values are in reference\n    // to the viewport origin (top left).\n    var lh, height, width, top;\n    if (obj.div) {\n      height = obj.div.offsetHeight;\n      width = obj.div.offsetWidth;\n      top = obj.div.offsetTop;\n\n      var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&\n                  rects.getClientRects && rects.getClientRects();\n      obj = obj.div.getBoundingClientRect();\n      // In certain cases the outter div will be slightly larger then the sum of\n      // the inner div's lines. This could be due to bold text, etc, on some platforms.\n      // In this case we should get the average line height and use that. This will\n      // result in the desired behaviour.\n      lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)\n                 : 0;\n\n    }\n    this.left = obj.left;\n    this.right = obj.right;\n    this.top = obj.top || top;\n    this.height = obj.height || height;\n    this.bottom = obj.bottom || (top + (obj.height || height));\n    this.width = obj.width || width;\n    this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n  }\n\n  // Move the box along a particular axis. Optionally pass in an amount to move\n  // the box. If no amount is passed then the default is the line height of the\n  // box.\n  BoxPosition.prototype.move = function(axis, toMove) {\n    toMove = toMove !== undefined ? toMove : this.lineHeight;\n    switch (axis) {\n    case \"+x\":\n      this.left += toMove;\n      this.right += toMove;\n      break;\n    case \"-x\":\n      this.left -= toMove;\n      this.right -= toMove;\n      break;\n    case \"+y\":\n      this.top += toMove;\n      this.bottom += toMove;\n      break;\n    case \"-y\":\n      this.top -= toMove;\n      this.bottom -= toMove;\n      break;\n    }\n  };\n\n  // Check if this box overlaps another box, b2.\n  BoxPosition.prototype.overlaps = function(b2) {\n    return this.left < b2.right &&\n           this.right > b2.left &&\n           this.top < b2.bottom &&\n           this.bottom > b2.top;\n  };\n\n  // Check if this box overlaps any other boxes in boxes.\n  BoxPosition.prototype.overlapsAny = function(boxes) {\n    for (var i = 0; i < boxes.length; i++) {\n      if (this.overlaps(boxes[i])) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Check if this box is within another box.\n  BoxPosition.prototype.within = function(container) {\n    return this.top >= container.top &&\n           this.bottom <= container.bottom &&\n           this.left >= container.left &&\n           this.right <= container.right;\n  };\n\n  // Check if this box is entirely within the container or it is overlapping\n  // on the edge opposite of the axis direction passed. For example, if \"+x\" is\n  // passed and the box is overlapping on the left edge of the container, then\n  // return true.\n  BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {\n    switch (axis) {\n    case \"+x\":\n      return this.left < container.left;\n    case \"-x\":\n      return this.right > container.right;\n    case \"+y\":\n      return this.top < container.top;\n    case \"-y\":\n      return this.bottom > container.bottom;\n    }\n  };\n\n  // Find the percentage of the area that this box is overlapping with another\n  // box.\n  BoxPosition.prototype.intersectPercentage = function(b2) {\n    var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n        y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n        intersectArea = x * y;\n    return intersectArea / (this.height * this.width);\n  };\n\n  // Convert the positions from this box to CSS compatible positions using\n  // the reference container's positions. This has to be done because this\n  // box's positions are in reference to the viewport origin, whereas, CSS\n  // values are in referecne to their respective edges.\n  BoxPosition.prototype.toCSSCompatValues = function(reference) {\n    return {\n      top: this.top - reference.top,\n      bottom: reference.bottom - this.bottom,\n      left: this.left - reference.left,\n      right: reference.right - this.right,\n      height: this.height,\n      width: this.width\n    };\n  };\n\n  // Get an object that represents the box's position without anything extra.\n  // Can pass a StyleBox, HTMLElement, or another BoxPositon.\n  BoxPosition.getSimpleBoxPosition = function(obj) {\n    var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n    var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n    var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n\n    obj = obj.div ? obj.div.getBoundingClientRect() :\n                  obj.tagName ? obj.getBoundingClientRect() : obj;\n    var ret = {\n      left: obj.left,\n      right: obj.right,\n      top: obj.top || top,\n      height: obj.height || height,\n      bottom: obj.bottom || (top + (obj.height || height)),\n      width: obj.width || width\n    };\n    return ret;\n  };\n\n  // Move a StyleBox to its specified, or next best, position. The containerBox\n  // is the box that contains the StyleBox, such as a div. boxPositions are\n  // a list of other boxes that the styleBox can't overlap with.\n  function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n\n    // Find the best position for a cue box, b, on the video. The axis parameter\n    // is a list of axis, the order of which, it will move the box along. For example:\n    // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n    // direction. If it doesn't find a good position for it there it will then move\n    // it along the x axis in the negative direction.\n    function findBestPosition(b, axis) {\n      var bestPosition,\n          specifiedPosition = new BoxPosition(b),\n          percentage = 1; // Highest possible so the first thing we get is better.\n\n      for (var i = 0; i < axis.length; i++) {\n        while (b.overlapsOppositeAxis(containerBox, axis[i]) ||\n               (b.within(containerBox) && b.overlapsAny(boxPositions))) {\n          b.move(axis[i]);\n        }\n        // We found a spot where we aren't overlapping anything. This is our\n        // best position.\n        if (b.within(containerBox)) {\n          return b;\n        }\n        var p = b.intersectPercentage(containerBox);\n        // If we're outside the container box less then we were on our last try\n        // then remember this position as the best position.\n        if (percentage > p) {\n          bestPosition = new BoxPosition(b);\n          percentage = p;\n        }\n        // Reset the box position to the specified position.\n        b = new BoxPosition(specifiedPosition);\n      }\n      return bestPosition || specifiedPosition;\n    }\n\n    var boxPosition = new BoxPosition(styleBox),\n        cue = styleBox.cue,\n        linePos = computeLinePos(cue),\n        axis = [];\n\n    // If we have a line number to align the cue to.\n    if (cue.snapToLines) {\n      var size;\n      switch (cue.vertical) {\n      case \"\":\n        axis = [ \"+y\", \"-y\" ];\n        size = \"height\";\n        break;\n      case \"rl\":\n        axis = [ \"+x\", \"-x\" ];\n        size = \"width\";\n        break;\n      case \"lr\":\n        axis = [ \"-x\", \"+x\" ];\n        size = \"width\";\n        break;\n      }\n\n      var step = boxPosition.lineHeight,\n          position = step * Math.round(linePos),\n          maxPosition = containerBox[size] + step,\n          initialAxis = axis[0];\n\n      // If the specified intial position is greater then the max position then\n      // clamp the box to the amount of steps it would take for the box to\n      // reach the max position.\n      if (Math.abs(position) > maxPosition) {\n        position = position < 0 ? -1 : 1;\n        position *= Math.ceil(maxPosition / step) * step;\n      }\n\n      // If computed line position returns negative then line numbers are\n      // relative to the bottom of the video instead of the top. Therefore, we\n      // need to increase our initial position by the length or width of the\n      // video, depending on the writing direction, and reverse our axis directions.\n      if (linePos < 0) {\n        position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n        axis = axis.reverse();\n      }\n\n      // Move the box to the specified position. This may not be its best\n      // position.\n      boxPosition.move(initialAxis, position);\n\n    } else {\n      // If we have a percentage line value for the cue.\n      var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;\n\n      switch (cue.lineAlign) {\n      case \"center\":\n        linePos -= (calculatedPercentage / 2);\n        break;\n      case \"end\":\n        linePos -= calculatedPercentage;\n        break;\n      }\n\n      // Apply initial line position to the cue box.\n      switch (cue.vertical) {\n      case \"\":\n        styleBox.applyStyles({\n          top: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n      case \"rl\":\n        styleBox.applyStyles({\n          left: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n      case \"lr\":\n        styleBox.applyStyles({\n          right: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n      }\n\n      axis = [ \"+y\", \"-x\", \"+x\", \"-y\" ];\n\n      // Get the box position again after we've applied the specified positioning\n      // to it.\n      boxPosition = new BoxPosition(styleBox);\n    }\n\n    var bestPosition = findBestPosition(boxPosition, axis);\n    styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n  }\n\n  function WebVTT() {\n    // Nothing\n  }\n\n  // Helper to allow strings to be decoded instead of the default binary utf8 data.\n  WebVTT.StringDecoder = function() {\n    return {\n      decode: function(data) {\n        if (!data) {\n          return \"\";\n        }\n        if (typeof data !== \"string\") {\n          throw new Error(\"Error - expected string data.\");\n        }\n        return decodeURIComponent(encodeURIComponent(data));\n      }\n    };\n  };\n\n  WebVTT.convertCueToDOMTree = function(window, cuetext) {\n    if (!window || !cuetext) {\n      return null;\n    }\n    return parseContent(window, cuetext);\n  };\n\n  var FONT_SIZE_PERCENT = 0.05;\n  var FONT_STYLE = \"sans-serif\";\n  var CUE_BACKGROUND_PADDING = \"1.5%\";\n\n  // Runs the processing model over the cues and regions passed to it.\n  // @param overlay A block level element (usually a div) that the computed cues\n  //                and regions will be placed into.\n  WebVTT.processCues = function(window, cues, overlay) {\n    if (!window || !cues || !overlay) {\n      return null;\n    }\n\n    // Remove all previous children.\n    while (overlay.firstChild) {\n      overlay.removeChild(overlay.firstChild);\n    }\n\n    var paddedOverlay = window.document.createElement(\"div\");\n    paddedOverlay.style.position = \"absolute\";\n    paddedOverlay.style.left = \"0\";\n    paddedOverlay.style.right = \"0\";\n    paddedOverlay.style.top = \"0\";\n    paddedOverlay.style.bottom = \"0\";\n    paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n    overlay.appendChild(paddedOverlay);\n\n    // Determine if we need to compute the display states of the cues. This could\n    // be the case if a cue's state has been changed since the last computation or\n    // if it has not been computed yet.\n    function shouldCompute(cues) {\n      for (var i = 0; i < cues.length; i++) {\n        if (cues[i].hasBeenReset || !cues[i].displayState) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // We don't need to recompute the cues' display states. Just reuse them.\n    if (!shouldCompute(cues)) {\n      for (var i = 0; i < cues.length; i++) {\n        paddedOverlay.appendChild(cues[i].displayState);\n      }\n      return;\n    }\n\n    var boxPositions = [],\n        containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n        fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n    var styleOptions = {\n      font: fontSize + \"px \" + FONT_STYLE\n    };\n\n    (function() {\n      var styleBox, cue;\n\n      for (var i = 0; i < cues.length; i++) {\n        cue = cues[i];\n\n        // Compute the intial position and styles of the cue div.\n        styleBox = new CueStyleBox(window, cue, styleOptions);\n        paddedOverlay.appendChild(styleBox.div);\n\n        // Move the cue div to it's correct line position.\n        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n        // Remember the computed div so that we don't have to recompute it later\n        // if we don't have too.\n        cue.displayState = styleBox.div;\n\n        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n      }\n    })();\n  };\n\n  WebVTT.Parser = function(window, vttjs, decoder) {\n    if (!decoder) {\n      decoder = vttjs;\n      vttjs = {};\n    }\n    if (!vttjs) {\n      vttjs = {};\n    }\n\n    this.window = window;\n    this.vttjs = vttjs;\n    this.state = \"INITIAL\";\n    this.buffer = \"\";\n    this.decoder = decoder || new TextDecoder(\"utf8\");\n    this.regionList = [];\n  };\n\n  WebVTT.Parser.prototype = {\n    // If the error is a ParsingError then report it to the consumer if\n    // possible. If it's not a ParsingError then throw it like normal.\n    reportOrThrowError: function(e) {\n      if (e instanceof ParsingError) {\n        this.onparsingerror && this.onparsingerror(e);\n      } else {\n        throw e;\n      }\n    },\n    parse: function (data) {\n      var self = this;\n\n      // If there is no data then we won't decode it, but will just try to parse\n      // whatever is in buffer already. This may occur in circumstances, for\n      // example when flush() is called.\n      if (data) {\n        // Try to decode the data that we received.\n        self.buffer += self.decoder.decode(data, {stream: true});\n      }\n\n      function collectNextLine() {\n        var buffer = self.buffer;\n        var pos = 0;\n        while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n          ++pos;\n        }\n        var line = buffer.substr(0, pos);\n        // Advance the buffer early in case we fail below.\n        if (buffer[pos] === '\\r') {\n          ++pos;\n        }\n        if (buffer[pos] === '\\n') {\n          ++pos;\n        }\n        self.buffer = buffer.substr(pos);\n        return line;\n      }\n\n      // 3.4 WebVTT region and WebVTT region settings syntax\n      function parseRegion(input) {\n        var settings = new Settings();\n\n        parseOptions(input, function (k, v) {\n          switch (k) {\n          case \"id\":\n            settings.set(k, v);\n            break;\n          case \"width\":\n            settings.percent(k, v);\n            break;\n          case \"lines\":\n            settings.integer(k, v);\n            break;\n          case \"regionanchor\":\n          case \"viewportanchor\":\n            var xy = v.split(',');\n            if (xy.length !== 2) {\n              break;\n            }\n            // We have to make sure both x and y parse, so use a temporary\n            // settings object here.\n            var anchor = new Settings();\n            anchor.percent(\"x\", xy[0]);\n            anchor.percent(\"y\", xy[1]);\n            if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n              break;\n            }\n            settings.set(k + \"X\", anchor.get(\"x\"));\n            settings.set(k + \"Y\", anchor.get(\"y\"));\n            break;\n          case \"scroll\":\n            settings.alt(k, v, [\"up\"]);\n            break;\n          }\n        }, /=/, /\\s/);\n\n        // Create the region, using default values for any values that were not\n        // specified.\n        if (settings.has(\"id\")) {\n          var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n          region.width = settings.get(\"width\", 100);\n          region.lines = settings.get(\"lines\", 3);\n          region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n          region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n          region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n          region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n          region.scroll = settings.get(\"scroll\", \"\");\n          // Register the region.\n          self.onregion && self.onregion(region);\n          // Remember the VTTRegion for later in case we parse any VTTCues that\n          // reference it.\n          self.regionList.push({\n            id: settings.get(\"id\"),\n            region: region\n          });\n        }\n      }\n\n      // draft-pantos-http-live-streaming-20\n      // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n      // 3.5 WebVTT\n      function parseTimestampMap(input) {\n        var settings = new Settings();\n\n        parseOptions(input, function(k, v) {\n          switch(k) {\n          case \"MPEGT\":\n            settings.integer(k + 'S', v);\n            break;\n          case \"LOCA\":\n            settings.set(k + 'L', parseTimeStamp(v));\n            break;\n          }\n        }, /[^\\d]:/, /,/);\n\n        self.ontimestampmap && self.ontimestampmap({\n          \"MPEGTS\": settings.get(\"MPEGTS\"),\n          \"LOCAL\": settings.get(\"LOCAL\")\n        });\n      }\n\n      // 3.2 WebVTT metadata header syntax\n      function parseHeader(input) {\n        if (input.match(/X-TIMESTAMP-MAP/)) {\n          // This line contains HLS X-TIMESTAMP-MAP metadata\n          parseOptions(input, function(k, v) {\n            switch(k) {\n            case \"X-TIMESTAMP-MAP\":\n              parseTimestampMap(v);\n              break;\n            }\n          }, /=/);\n        } else {\n          parseOptions(input, function (k, v) {\n            switch (k) {\n            case \"Region\":\n              // 3.3 WebVTT region metadata header syntax\n              parseRegion(v);\n              break;\n            }\n          }, /:/);\n        }\n\n      }\n\n      // 5.1 WebVTT file parsing.\n      try {\n        var line;\n        if (self.state === \"INITIAL\") {\n          // We can't start parsing until we have the first line.\n          if (!/\\r\\n|\\n/.test(self.buffer)) {\n            return this;\n          }\n\n          line = collectNextLine();\n\n          var m = line.match(/^WEBVTT([ \\t].*)?$/);\n          if (!m || !m[0]) {\n            throw new ParsingError(ParsingError.Errors.BadSignature);\n          }\n\n          self.state = \"HEADER\";\n        }\n\n        var alreadyCollectedLine = false;\n        while (self.buffer) {\n          // We can't parse a line until we have the full line.\n          if (!/\\r\\n|\\n/.test(self.buffer)) {\n            return this;\n          }\n\n          if (!alreadyCollectedLine) {\n            line = collectNextLine();\n          } else {\n            alreadyCollectedLine = false;\n          }\n\n          switch (self.state) {\n          case \"HEADER\":\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              self.state = \"ID\";\n            }\n            continue;\n          case \"NOTE\":\n            // Ignore NOTE blocks.\n            if (!line) {\n              self.state = \"ID\";\n            }\n            continue;\n          case \"ID\":\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              self.state = \"NOTE\";\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n            // Safari still uses the old middle value and won't accept center\n            try {\n              self.cue.align = \"center\";\n            } catch (e) {\n              self.cue.align = \"middle\";\n            }\n            self.state = \"CUE\";\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf(\"-->\") === -1) {\n              self.cue.id = line;\n              continue;\n            }\n            // Process line as start of a cue.\n            /*falls through*/\n          case \"CUE\":\n            // 40 - Collect cue timings and settings.\n            try {\n              parseCue(line, self.cue, self.regionList);\n            } catch (e) {\n              self.reportOrThrowError(e);\n              // In case of an error ignore rest of the cue.\n              self.cue = null;\n              self.state = \"BADCUE\";\n              continue;\n            }\n            self.state = \"CUETEXT\";\n            continue;\n          case \"CUETEXT\":\n            var hasSubstring = line.indexOf(\"-->\") !== -1;\n            // 34 - If we have an empty line then report the cue.\n            // 35 - If we have the special substring '-->' then report the cue,\n            // but do not collect the line as we need to process the current\n            // one as a new cue.\n            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n              // We are done parsing self cue.\n              self.oncue && self.oncue(self.cue);\n              self.cue = null;\n              self.state = \"ID\";\n              continue;\n            }\n            if (self.cue.text) {\n              self.cue.text += \"\\n\";\n            }\n            self.cue.text += line.replace(/\\u2028/g, '\\n').replace(/u2029/g, '\\n');\n            continue;\n          case \"BADCUE\": // BADCUE\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              self.state = \"ID\";\n            }\n            continue;\n          }\n        }\n      } catch (e) {\n        self.reportOrThrowError(e);\n\n        // If we are currently parsing a cue, report what we have.\n        if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n          self.oncue(self.cue);\n        }\n        self.cue = null;\n        // Enter BADWEBVTT state if header was not parsed correctly otherwise\n        // another exception occurred so enter BADCUE state.\n        self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n      }\n      return this;\n    },\n    flush: function () {\n      var self = this;\n      try {\n        // Finish decoding the stream.\n        self.buffer += self.decoder.decode();\n        // Synthesize the end of the current cue or region.\n        if (self.cue || self.state === \"HEADER\") {\n          self.buffer += \"\\n\\n\";\n          self.parse();\n        }\n        // If we've flushed, parsed, and we're still on the INITIAL state then\n        // that means we don't have enough of the stream to parse the first\n        // line.\n        if (self.state === \"INITIAL\") {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n      } catch(e) {\n        self.reportOrThrowError(e);\n      }\n      self.onflush && self.onflush();\n      return this;\n    }\n  };\n\n  return WebVTT;\n\n\n});\ndefine('skylark-videojs-vtt/vttcue',[\n  \"./vtt\"\n],function(WebVTT){\n  /**\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var autoKeyword = \"auto\";\n  var directionSetting = {\n    \"\": 1,\n    \"lr\": 1,\n    \"rl\": 1\n  };\n  var alignSetting = {\n    \"start\": 1,\n    \"center\": 1,\n    \"end\": 1,\n    \"left\": 1,\n    \"right\": 1,\n    \"auto\": 1,\n    \"line-left\": 1,\n    \"line-right\": 1\n  };\n\n  function findDirectionSetting(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    var dir = directionSetting[value.toLowerCase()];\n    return dir ? value.toLowerCase() : false;\n  }\n\n  function findAlignSetting(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    var align = alignSetting[value.toLowerCase()];\n    return align ? value.toLowerCase() : false;\n  }\n\n  function VTTCue(startTime, endTime, text) {\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    this.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    var _id = \"\";\n    var _pauseOnExit = false;\n    var _startTime = startTime;\n    var _endTime = endTime;\n    var _text = text;\n    var _region = null;\n    var _vertical = \"\";\n    var _snapToLines = true;\n    var _line = \"auto\";\n    var _lineAlign = \"start\";\n    var _position = \"auto\";\n    var _positionAlign = \"auto\";\n    var _size = 100;\n    var _align = \"center\";\n\n    Object.defineProperties(this, {\n      \"id\": {\n        enumerable: true,\n        get: function() {\n          return _id;\n        },\n        set: function(value) {\n          _id = \"\" + value;\n        }\n      },\n\n      \"pauseOnExit\": {\n        enumerable: true,\n        get: function() {\n          return _pauseOnExit;\n        },\n        set: function(value) {\n          _pauseOnExit = !!value;\n        }\n      },\n\n      \"startTime\": {\n        enumerable: true,\n        get: function() {\n          return _startTime;\n        },\n        set: function(value) {\n          if (typeof value !== \"number\") {\n            throw new TypeError(\"Start time must be set to a number.\");\n          }\n          _startTime = value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"endTime\": {\n        enumerable: true,\n        get: function() {\n          return _endTime;\n        },\n        set: function(value) {\n          if (typeof value !== \"number\") {\n            throw new TypeError(\"End time must be set to a number.\");\n          }\n          _endTime = value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"text\": {\n        enumerable: true,\n        get: function() {\n          return _text;\n        },\n        set: function(value) {\n          _text = \"\" + value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"region\": {\n        enumerable: true,\n        get: function() {\n          return _region;\n        },\n        set: function(value) {\n          _region = value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"vertical\": {\n        enumerable: true,\n        get: function() {\n          return _vertical;\n        },\n        set: function(value) {\n          var setting = findDirectionSetting(value);\n          // Have to check for false because the setting an be an empty string.\n          if (setting === false) {\n            throw new SyntaxError(\"Vertical: an invalid or illegal direction string was specified.\");\n          }\n          _vertical = setting;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"snapToLines\": {\n        enumerable: true,\n        get: function() {\n          return _snapToLines;\n        },\n        set: function(value) {\n          _snapToLines = !!value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"line\": {\n        enumerable: true,\n        get: function() {\n          return _line;\n        },\n        set: function(value) {\n          if (typeof value !== \"number\" && value !== autoKeyword) {\n            throw new SyntaxError(\"Line: an invalid number or illegal string was specified.\");\n          }\n          _line = value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"lineAlign\": {\n        enumerable: true,\n        get: function() {\n          return _lineAlign;\n        },\n        set: function(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            console.warn(\"lineAlign: an invalid or illegal string was specified.\");\n          } else {\n            _lineAlign = setting;\n            this.hasBeenReset = true;\n          }\n        }\n      },\n\n      \"position\": {\n        enumerable: true,\n        get: function() {\n          return _position;\n        },\n        set: function(value) {\n          if (value < 0 || value > 100) {\n            throw new Error(\"Position must be between 0 and 100.\");\n          }\n          _position = value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"positionAlign\": {\n        enumerable: true,\n        get: function() {\n          return _positionAlign;\n        },\n        set: function(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            console.warn(\"positionAlign: an invalid or illegal string was specified.\");\n          } else {\n            _positionAlign = setting;\n            this.hasBeenReset = true;\n          }\n        }\n      },\n\n      \"size\": {\n        enumerable: true,\n        get: function() {\n          return _size;\n        },\n        set: function(value) {\n          if (value < 0 || value > 100) {\n            throw new Error(\"Size must be between 0 and 100.\");\n          }\n          _size = value;\n          this.hasBeenReset = true;\n        }\n      },\n\n      \"align\": {\n        enumerable: true,\n        get: function() {\n          return _align;\n        },\n        set: function(value) {\n          var setting = findAlignSetting(value);\n          if (!setting) {\n            throw new SyntaxError(\"align: an invalid or illegal alignment string was specified.\");\n          }\n          _align = setting;\n          this.hasBeenReset = true;\n        }\n      }\n    });\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    this.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function() {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    return WebVTT.convertCueToDOMTree(window, this.text);\n  };\n\n  return VTTCue;\n});\n\ndefine('skylark-videojs-vtt/vttregion',[\n],function(){\n  /**\n   * Copyright 2013 vtt.js Contributors\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *   http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   */\n\n  var scrollSetting = {\n    \"\": true,\n    \"up\": true\n  };\n\n  function findScrollSetting(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    var scroll = scrollSetting[value.toLowerCase()];\n    return scroll ? value.toLowerCase() : false;\n  }\n\n  function isValidPercentValue(value) {\n    return typeof value === \"number\" && (value >= 0 && value <= 100);\n  }\n\n  // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\n  function VTTRegion() {\n    var _width = 100;\n    var _lines = 3;\n    var _regionAnchorX = 0;\n    var _regionAnchorY = 100;\n    var _viewportAnchorX = 0;\n    var _viewportAnchorY = 100;\n    var _scroll = \"\";\n\n    Object.defineProperties(this, {\n      \"width\": {\n        enumerable: true,\n        get: function() {\n          return _width;\n        },\n        set: function(value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"Width must be between 0 and 100.\");\n          }\n          _width = value;\n        }\n      },\n      \"lines\": {\n        enumerable: true,\n        get: function() {\n          return _lines;\n        },\n        set: function(value) {\n          if (typeof value !== \"number\") {\n            throw new TypeError(\"Lines must be set to a number.\");\n          }\n          _lines = value;\n        }\n      },\n      \"regionAnchorY\": {\n        enumerable: true,\n        get: function() {\n          return _regionAnchorY;\n        },\n        set: function(value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n          }\n          _regionAnchorY = value;\n        }\n      },\n      \"regionAnchorX\": {\n        enumerable: true,\n        get: function() {\n          return _regionAnchorX;\n        },\n        set: function(value) {\n          if(!isValidPercentValue(value)) {\n            throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n          }\n          _regionAnchorX = value;\n        }\n      },\n      \"viewportAnchorY\": {\n        enumerable: true,\n        get: function() {\n          return _viewportAnchorY;\n        },\n        set: function(value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n          }\n          _viewportAnchorY = value;\n        }\n      },\n      \"viewportAnchorX\": {\n        enumerable: true,\n        get: function() {\n          return _viewportAnchorX;\n        },\n        set: function(value) {\n          if (!isValidPercentValue(value)) {\n            throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n          }\n          _viewportAnchorX = value;\n        }\n      },\n      \"scroll\": {\n        enumerable: true,\n        get: function() {\n          return _scroll;\n        },\n        set: function(value) {\n          var setting = findScrollSetting(value);\n          // Have to check for false as an empty string is a legal value.\n          if (setting === false) {\n            console.warn(\"Scroll: an invalid or illegal string was specified.\");\n          } else {\n            _scroll = setting;\n          }\n        }\n      }\n    });\n  }\n\n  return VTTRegion;\n});\ndefine('skylark-videojs-vtt/main',[\n\t\"./vtt\",\n\t\"./vttcue\",\n\t\"./vttregion\"\n],function(WebVTT,VTTCue,VTTRegion){\n\treturn {\n\t\tWebVTT,\n\t\tVTTCue,\n\t\tVTTRegion\n\t};\n});\n\n\ndefine('skylark-videojs-vtt', ['skylark-videojs-vtt/main'], function (main) { return main; });\n\n"]}